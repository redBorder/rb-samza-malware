package net.redborder.samza.aerospike;

import com.aerospike.client.Bin;
import com.aerospike.client.Host;
import com.aerospike.client.Key;
import com.aerospike.client.async.AsyncClient;
import com.aerospike.client.async.AsyncClientPolicy;
import com.aerospike.client.policy.RecordExistsAction;
import com.aerospike.client.policy.WritePolicy;
import org.apache.samza.config.Config;
import org.apache.samza.system.OutgoingMessageEnvelope;
import org.apache.samza.system.SystemProducer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

public class AerospikeSystemProducer implements SystemProducer {
    private static final Logger log = LoggerFactory.getLogger(AerospikeSystemProducer.class);

    AsyncClient client;
    List<String> hosts;
    Integer timeout;
    WritePolicy writePolicy;
    Config config;

    Map<Key, LinkedList<Map<String, Object>>> localCache;

    public AerospikeSystemProducer(String metadata, Config config) {
        this.config = config;
        this.hosts = config.getList("systems.aerospike.servers");
        this.timeout = config.getInt("systems.aerospike.clientTimeout", 500);
        this.localCache = new LinkedHashMap<>();
        this.writePolicy = new WritePolicy();
        this.writePolicy.recordExistsAction = RecordExistsAction.UPDATE;
    }

    @Override
    public void start() {
        init();
    }

    private void init(){
        List<Host> servers = new ArrayList<>();

        for (String host : hosts) {
            String[] sp = host.split(":");
            servers.add(new Host(sp[0], Integer.parseInt(sp[1])));
        }

        AsyncClientPolicy cPolicy = new AsyncClientPolicy();
        cPolicy.timeout = timeout;

        client = new AsyncClient(cPolicy, servers.toArray(new Host[servers.size()]));
    }

    @Override
    public void stop() {
        client.close();
    }

    @Override
    public void register(String s) {

    }

    @Override
    public void send(String s, OutgoingMessageEnvelope messageEnvelope) {
        Map<String, Object> message = (Map<String, Object>) messageEnvelope.getMessage();
        String collectionId = messageEnvelope.getSystemStream().getStream();
        String namespace = config.get("systems.aerospike." + collectionId + ".namespace");
        String collection = config.get("systems.aerospike." + collectionId + ".collection");
        List<String> keysNames = config.getList("systems.aerospike." + collectionId + ".keyField");
        List<String> columns = config.getList("systems.aerospike." + collectionId + ".columns");

        StringBuffer key = new StringBuffer();
        boolean allKeys = true;

        for (String keyName : keysNames) {
            String value = (String) message.get(keyName);

            if (value != null) {
                key.append(value);
            } else {
                allKeys = false;
            }
        }

        if (allKeys) {
            Key asKey = new Key(namespace, collection, key.toString());
            List<Bin> bins = new ArrayList<>();

            log.debug("Sending message to AeroSpike key:[{}]", key.toString());
            for (String column : columns) {
                Object value = message.get(column);
                if (value != null) {
                    bins.add(new Bin(column, value));
                }
            }

            if (client.isConnected()) {
                client.put(writePolicy, asKey, bins.toArray(new Bin[bins.size()]));
            } else {
                stop();
                init();
            }
        }
    }

    @Override
    public void flush(String s) {

    }
}
