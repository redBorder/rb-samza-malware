package net.redborder.samza.processors;

import com.google.common.base.Joiner;
import net.redborder.samza.enrichments.EnrichManager;
import net.redborder.samza.store.StoreExtensionKey;
import net.redborder.samza.store.StoreManager;
import net.redborder.samza.stores.AerospikeStore;
import net.redborder.samza.util.constants.Constants;
import net.redborder.samza.util.constants.Dimension;
import org.apache.samza.config.Config;
import org.apache.samza.metrics.Counter;
import org.apache.samza.system.OutgoingMessageEnvelope;
import org.apache.samza.system.SystemStream;
import org.apache.samza.task.MessageCollector;
import org.apache.samza.task.TaskContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static net.redborder.samza.util.constants.Dimension.*;

public class MailGwProcessor extends Processor {
    private static final SystemStream OUTPUT_STREAM = new SystemStream("kafka", Constants.ENRICHMENT_MALWARE_OUTPUT_TOPIC);
    private static final SystemStream MAIL_OUTPUT_STREAM = new SystemStream("kafka", Constants.ENRICHMENT_MAIL_OUTPUT_TOPIC);

    private static final Logger log = LoggerFactory.getLogger(MailGwProcessor.class);

    private Counter messagesCounter;
    private AerospikeStore aerospike;

    public MailGwProcessor(StoreManager storeManager, EnrichManager enrichManager, Config config, TaskContext context) {
        super(storeManager, enrichManager, config, context);
        this.messagesCounter = context.getMetricsRegistry().newCounter(getClass().getName(), "messages");
        this.aerospike = (AerospikeStore) storeManager.getExtension("aerospike");
    }

    @Override
    public void process(Map<String, Object> message, MessageCollector collector) {
        List<Map<String, String>> files = (List<Map<String, String>>) message.remove(FILES);
        List<String> urls = (List<String>) message.remove(URLS);
        String headers = (String) message.remove(HEADERS);
        List<String> receivers = (List<String>) message.remove(EMAIL_DESTINATIONS);
        Object timestamp = message.get(TIMESTAMP);

        for (String receive : receivers) {


            if (files != null) {
                Map<String, Object> hashDruid = new HashMap<>();
                hashDruid.put(EMAIL_DESTINATION, receive);

                for (Map<String, String> file : files) {
                    aerospike.updateHashTimes(timestamp, file.get(HASH), Constants.EventType.hash);
                    hashDruid.putAll(message);

                    if (file.get("name") != null) {
                        hashDruid.put(Dimension.FILE_NAME, file.get("name"));
                    }

                    if (file.get("size") != null) {
                        hashDruid.put(Dimension.FILE_SIZE, file.get("size"));
                    }

                    if (file.get(Dimension.PROBE_SCORE) != null) {
                        hashDruid.put(Dimension.PROBE_SCORE, file.get(Dimension.PROBE_SCORE));
                    }

                    hashDruid.put(Dimension.HASH, file.get(HASH));
                    Map<String, Object> msgIpScores = aerospike.enrichIpScores(hashDruid);
                    Map<String, Object> msgHashScores = aerospike.enrichHashScores(msgIpScores);
                    msgHashScores.put(TYPE, "mail-gw");
                    collector.send(new OutgoingMessageEnvelope(OUTPUT_STREAM, msgHashScores));
                }
            }

            if (urls != null) {
                Map<String, Object> urlDruid = new HashMap<>();
                urlDruid.put(EMAIL_DESTINATION, receive);

                log.info("URLS: {}", urls);
                for (String url : urls) {
                    aerospike.updateHashTimes(timestamp, url, Constants.EventType.url);
                    urlDruid.putAll(message);
                    urlDruid.put(Dimension.URL, url);
                    Map<String, Object> msgIpScores = aerospike.enrichIpScores(urlDruid);
                    Map<String, Object> msgUrlScores = aerospike.enrichUrlScores(msgIpScores);
                    msgUrlScores.put(TYPE, "mail-gw");
                    collector.send(new OutgoingMessageEnvelope(OUTPUT_STREAM, msgUrlScores));
                }
            }
        }

        String action = (String) message.get(ACTION);
        String emailId = (String) message.get(EMAIL_ID);

        StoreExtensionKey emailIdKey = new StoreExtensionKey.Builder()
                .namespace("malware")
                .collection("mailQuarantine")
                .key(emailId)
                .build();

        if (action != null && action.equals("QUARANTINE")) {

            if (emailId != null) {
                String sender = (String) message.get(EMAIL_SENDER);

                Integer filesCount = files != null ? files.size() : 0;
                Integer urlsCount = urls != null ? urls.size() : 0;

                Map<String, Object> qData = new HashMap<>();
                qData.put(TIMESTAMP, timestamp);
                qData.put(EMAIL_ID, emailId);
                qData.put("email_src", sender);
                qData.put("email_dsts", Joiner.on(",").join(receivers));
                qData.put("files", filesCount);
                qData.put("urls", urlsCount);

                aerospike.put(emailIdKey, qData);
            } else {
                log.warn("Email [{}] without Email ID.", message);
            }
        } else {
            if (aerospike.exist(emailIdKey)) {
                aerospike.remove(emailIdKey);
            }
        }

        String subject = (String) message.get(SUBJECT);

        Map<String, Object> toMail = new HashMap<>();
        toMail.put(HEADERS, headers);
        toMail.put(EMAIL_ID, emailId);
        toMail.put(SUBJECT, subject);
        toMail.put(TYPE, "mail-gw");
        collector.send(new OutgoingMessageEnvelope(MAIL_OUTPUT_STREAM, toMail));
        messagesCounter.inc();
    }

    @Override
    public String getName() {
        return "MAIL-GW";
    }


}
