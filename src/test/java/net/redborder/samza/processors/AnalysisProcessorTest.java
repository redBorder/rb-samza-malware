package net.redborder.samza.processors;

import junit.framework.TestCase;
import net.redborder.samza.enrichments.EnrichManager;
import net.redborder.samza.store.StoreManager;
import net.redborder.samza.util.constants.Dimension;
import net.redborder.samza.util.testing.MockKeyValueStore;
import net.redborder.samza.util.testing.MockMessageCollector;
import net.redborder.samza.util.testing.MockTaskContext;
import org.apache.samza.config.Config;
import org.apache.samza.task.TaskContext;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;

import java.util.HashMap;
import java.util.Map;

import static org.mockito.Matchers.anyMap;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import static net.redborder.samza.util.constants.Dimension.*;

@RunWith(MockitoJUnitRunner.class)
public class AnalysisProcessorTest extends TestCase {
    static MockKeyValueStore storeAnalysis;

    static AnalysisProcessor analysisProcessor;
    static EnrichManager enrichManager;

    @Mock
    static StoreManager storeManager;

    @Mock
    static Config config;

    static TaskContext taskContext;

    @BeforeClass
    public static void initTest() {
        // This store uses an in-memory map instead of samza K/V RockDB
        storeAnalysis = new MockKeyValueStore();
        taskContext = new MockTaskContext();
        config = mock(Config.class);

        // Mock the storeManager in order to return the mock store
        // that we just instantiated
        storeManager = mock(StoreManager.class);
        when(storeManager.getStore(AnalysisProcessor.ANALYSIS_STORE)).thenReturn(storeAnalysis);
        when(storeManager.enrich(anyMap())).thenAnswer(new Answer<Map<String, Object>>() {
            @Override
            public Map<String, Object> answer(InvocationOnMock invocation) throws Throwable {
                Object[] args = invocation.getArguments();
                return (Map<String, Object>) args[0];
            }
        });

        enrichManager = new EnrichManager();
        analysisProcessor = new AnalysisProcessor(storeManager, enrichManager, config, taskContext);
    }

    @Before
    // Cleans the store in order to use an empty
    // memory map in each test
    public void cleanStore() {
        storeAnalysis.flush();
    }

    @Test
    public void checkAnalysisCacheStorage() {
        MockMessageCollector collector = new MockMessageCollector();
        Map<String, Object> message = new HashMap<>();
        String sha256 = "XYZ";
        String namespaceUuid = "12345";
        message.put(NAMESPACE_UUID, namespaceUuid);
        message.put(SHA256, sha256);
        message.put(TIMESTAMP, Long.valueOf(1429088471L));
        message.put(MALWARE_NAME, "Trojan4x");
        message.put(ENGINE, "ClamAV");
        message.put(TYPE, "file-loaders");
        message.put(SCORE, 90);
        analysisProcessor.process(message, collector);

        Map<String, Object> cache = new HashMap<>();
        cache.put(MALWARE_NAME, "Trojan4x");
        cache.put(ENGINE, "ClamAV");
        cache.put(SCORE, 90);

        assertEquals(cache, storeAnalysis.get(sha256 + namespaceUuid));
    }

    @Test
    public void checkAnalysisCacheStorageFailed() {
        MockMessageCollector collector = new MockMessageCollector();
        Map<String, Object> message = new HashMap<>();
        String sha256 = "XYZ";
        String namespaceUuid = "12345";
        message.put(NAMESPACE_UUID, namespaceUuid);
        message.put(SHA256, sha256);
        message.put(TIMESTAMP, Long.valueOf(1429088471L));
        message.put(MALWARE_NAME, "Trojan4x");
        message.put(TYPE, "ClamAV");
        message.put(SCORE, 90);
        analysisProcessor.process(message, collector);

        assertNull(storeAnalysis.get(sha256 + "OTHER_NAMESPACE"));
    }

    @Test
    public void checkAnalysisDruidSend() {
        MockMessageCollector collector = new MockMessageCollector();
        Map<String, Object> message = new HashMap<>();
        String sha256 = "XYZ";
        String namespaceUuid = "12345";
        message.put(NAMESPACE_UUID, namespaceUuid);
        message.put(SHA256, sha256);
        message.put(TIMESTAMP, Long.valueOf(1429088471L));
        message.put(MALWARE_NAME, "Trojan4x");
        message.put(TYPE, "ClamAV");
        message.put(SCORE, 90);
        analysisProcessor.process(message, collector);

        assertEquals(message, collector.getResult().get(0));
    }


    @Test
    public void getNameTest() {
        assertEquals("analysis", analysisProcessor.getName());
    }
}
