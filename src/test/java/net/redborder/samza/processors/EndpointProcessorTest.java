package net.redborder.samza.processors;

import junit.framework.TestCase;

import net.redborder.samza.enrichments.EnrichManager;
import net.redborder.samza.store.StoreExtensionKey;
import net.redborder.samza.store.StoreManager;
import net.redborder.samza.stores.AerospikeStore;
import net.redborder.samza.util.MockMessageCollector;
import net.redborder.samza.util.MockTaskContext;
import org.apache.http.conn.HttpHostConnectException;
import org.apache.samza.config.Config;
import org.apache.samza.task.TaskContext;
import org.codehaus.jackson.map.ObjectMapper;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;

import java.io.IOException;
import java.lang.reflect.Field;
import java.net.ConnectException;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class EndpointProcessorTest extends TestCase{

    static Map<String, Object> database;

    ObjectMapper mapper = new ObjectMapper();

    static EndpointProcessor endpointProcessor;
    static EnrichManager enrichManager;

    @Mock
    static Config config;

    @Mock
    static StoreManager storeManager;

    @Mock
    static AerospikeStore mockAerospikeStore;
    static TaskContext taskContext;


    @BeforeClass
    public static void initTest() {

        database = new HashMap<>();

        taskContext = new MockTaskContext();

        config = mock(Config.class);
        storeManager = mock(StoreManager.class);
        mockAerospikeStore = mock(AerospikeStore.class);

        // Mock AerospikeStore
        when(storeManager.getExtension("aerospike")).thenReturn(mockAerospikeStore);

        // Return petition (Will throw exception)
        when(mockAerospikeStore.makeRandomReputationURL()).thenReturn("http://localhost:7777/reputation/v1/malware/query");

        // Real call to enrichHashScores method
        when(mockAerospikeStore.enrichHashScores(anyMap())).thenCallRealMethod();

        when(mockAerospikeStore.get(any(StoreExtensionKey.class))).thenAnswer(new Answer<Object>() {
            @Override
            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {

                StoreExtensionKey sek = (StoreExtensionKey) invocationOnMock.getArguments()[0];
                String key = sek.key;

                Map<String, Object> returnMap = new HashMap<String, Object>();


                if(key.equals("AAAA")){
                    returnMap.put("list_type", "white");
                    returnMap.put("hash", key);
                }else if (key.equals("BBBB")){
                    returnMap.put("list_type", "black");
                    returnMap.put("hash", key);
                }else if(key.equals("CCCC")){
                    returnMap.put("hash", key);
                }

                return returnMap;
            }
        });

        enrichManager = new EnrichManager();

        endpointProcessor = new EndpointProcessor(storeManager, enrichManager, config, taskContext);

    }


    @Test
    public void enrichUnknowHashCorrectly(){

        MockMessageCollector collector = new MockMessageCollector();

        Map<String, Object> message = new HashMap<>();
        message.put("hash", "CCCC");
        message.put("timestamp", new Date(0L).getTime());

        Map<String, Object> expectedMessage = new HashMap<>();
        expectedMessage.put("hash", "CCCC");
        expectedMessage.put("timestamp", new Date(0L).getTime());
        expectedMessage.put("list_type", "none");
        expectedMessage.put("hash_score", -1);
        expectedMessage.put("type", "endpoint");

        endpointProcessor.process(message, collector);

        assertEquals(expectedMessage, collector.getResult().get(0));
    }

    @Test
    public void enrichBlackHashCorrectly(){

        MockMessageCollector collector = new MockMessageCollector();

        Map<String, Object> message = new HashMap<>();
        message.put("hash", "BBBB");
        message.put("timestamp", new Date(0L).getTime());

        Map<String, Object> expectedMessage = new HashMap<>();
        expectedMessage.put("hash", "BBBB");
        expectedMessage.put("timestamp", new Date(0L).getTime());
        expectedMessage.put("list_type", "black");
        expectedMessage.put("hash_score", 100);
        expectedMessage.put("type", "endpoint");

        endpointProcessor.process(message, collector);

        assertEquals(expectedMessage, collector.getResult().get(0));
    }

    @Test
    public void enrichWhiteHashCorrectly(){

        MockMessageCollector collector = new MockMessageCollector();

        Map<String, Object> message = new HashMap<>();
        message.put("hash", "AAAA");
        message.put("timestamp", new Date(0L).getTime());

        Map<String, Object> expectedMessage = new HashMap<>();
        expectedMessage.put("hash", "AAAA");
        expectedMessage.put("timestamp", new Date(0L).getTime());
        expectedMessage.put("list_type", "white");
        expectedMessage.put("hash_score", 0);
        expectedMessage.put("type", "endpoint");

        endpointProcessor.process(message, collector);

        assertEquals(expectedMessage, collector.getResult().get(0));
    }

    @Test
    public void lazyMessageCorrectly() throws IOException {

        MockMessageCollector collector = new MockMessageCollector();

        String hash = "ABCD";
        long timestamp = new Date(0L).getTime();

        // New message
        Map<String, Object> message = new HashMap<>();
        message.put("hash", hash);
        message.put("timestamp", timestamp);

        Map<String, Object> expectedMessage = new HashMap<>();
        expectedMessage.put("hash_score", -1);
        expectedMessage.put("list_type", "none");
        expectedMessage.put("hash", hash);
        expectedMessage.put("timestamp", timestamp);
        expectedMessage.put("type", "endpoint");

        endpointProcessor.process(message, collector);

        assertEquals(expectedMessage, collector.getResult().get(0));

    }

    @Test
    public void getNameTest(){
        assertEquals("ENDPOINT", endpointProcessor.getName());
    }

}
