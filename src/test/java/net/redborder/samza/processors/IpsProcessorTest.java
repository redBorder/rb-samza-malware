package net.redborder.samza.processors;

import junit.framework.TestCase;
import net.redborder.samza.enrichments.EnrichManager;
import net.redborder.samza.store.StoreExtensionKey;
import net.redborder.samza.store.StoreManager;
import net.redborder.samza.stores.AerospikeStore;
import net.redborder.samza.util.MockKeyValueStore;
import net.redborder.samza.util.MockMessageCollector;
import net.redborder.samza.util.MockTaskContext;
import net.redborder.samza.util.constants.Constants;
import org.apache.commons.collections.map.HashedMap;
import org.apache.samza.config.Config;
import org.apache.samza.task.TaskContext;
import org.codehaus.jackson.map.ObjectMapper;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;

import java.util.*;

import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class IpsProcessorTest extends TestCase {

    static MockKeyValueStore storeScores;

    static IpsProcessor ipsProcessor;
    static EnrichManager enrichManager;

    @Mock
    static Config config;

    @Mock
    static StoreManager storeManager;

    @Mock
    static AerospikeStore mockAerospikeStore;

    static TaskContext taskContext;

    static ArrayList<Map<String, Object>> enrichMessages;


    @BeforeClass
    public static void initTest(){
        enrichMessages = new ArrayList<>();

        storeScores = new MockKeyValueStore();
        taskContext = new MockTaskContext();
        enrichManager = new EnrichManager();

        config = mock(Config.class);
        storeManager = mock(StoreManager.class);
        mockAerospikeStore = mock(AerospikeStore.class);

        when(storeManager.getExtension("aerospike")).thenReturn(mockAerospikeStore);

        doCallRealMethod().when(mockAerospikeStore).updateHashTimes(anyObject(), anyString(), (Constants.EventType) anyObject());

        when(mockAerospikeStore.exist(any(StoreExtensionKey.class))).thenAnswer(new Answer<Object>() {
            @Override
            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {

                StoreExtensionKey extensionKey = (StoreExtensionKey) invocationOnMock.getArguments()[0];

                String key = extensionKey.key;

                boolean exist = false;

                  if(key.equals("AAAA")){
                        exist = true;
                    }else if(key.equals("BBBB")) {
                      exist = false;
                  }

                return exist;
            }
        });

        doAnswer(new Answer() {
            @Override
            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {

                enrichMessages.add((Map<String, Object>) invocationOnMock.getArguments()[1]);

                return null;

            }

        }).when(mockAerospikeStore).put(any(StoreExtensionKey.class), anyMap());

        // Real call to enrichHashScores method
        when(mockAerospikeStore.enrichHashScores(anyMap())).thenCallRealMethod();

        // Real call to enrichHashScores method
        when(mockAerospikeStore.enrichUrlScores(anyMap())).thenCallRealMethod();

        // Real call to enrichHashScores method
        when(mockAerospikeStore.enrichIpScores(anyMap())).thenCallRealMethod();

        when(mockAerospikeStore.makeRandomReputationURL()).thenReturn("http://localhost:7777/reputation/v1/malware/query");

        when(mockAerospikeStore.get(any(StoreExtensionKey.class))).thenAnswer(new Answer<Object>() {
            @Override
            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {

                StoreExtensionKey extensionKey = (StoreExtensionKey) invocationOnMock.getArguments()[0];

                String key = extensionKey.key;
                String collection = extensionKey.collection;

                Map<String, Object> returnMap = new HashMap<String, Object>();

                Random r = new Random();

                if(collection.equals("hashScores")){
                    if(key.equals("AAAA")){
                        returnMap.put("list_type", "white");
                        returnMap.put("hash", key);
                    }else if (key.equals("BBBB")){
                        returnMap.put("list_type", "black");
                        returnMap.put("hash", key);
                    }else if(key.equals("CCCC")){
                         returnMap.put("hash", key);
                    }
                }else if(collection.equals("urlScores")){
                    if(key.equals("http://127.0.0.1/someURI_AAAA")){
                        returnMap.put("list_type", "white");
                        returnMap.put("url", key);
                    }else if(key.equals("http://127.0.0.1/someURI_BBBB")){
                        returnMap.put("list_type", "black");
                        returnMap.put("url", key);
                    }else if(key.equals("http://127.0.0.1/someURI_CCCC")){
                        returnMap.put("url", key);
                    }

                }else if(collection.equals("ipScores")){
                    if(key.equals("1.2.3.4")){
                        returnMap.put("list_type", "white");
                     }else if (key.equals("4.3.2.1")){
                        returnMap.put("list_type", "black");
                    }
                }


                return returnMap;
            }
        });

        ipsProcessor = new IpsProcessor(storeManager, enrichManager, config, taskContext);
    }

    @Test
    public void processMessageCorrectly(){
        MockMessageCollector collector = new MockMessageCollector();

        Map<String, Object> message = new HashMap<>();
        message.put("sha256", "AAAA");
        message.put("timestamp", new Date(1111).getTime());
        message.put("file_hostname", "127.0.0.1");
        message.put("file_uri", "/someURI_AAAA");
        message.put("src","1.2.3.4");
        message.put("dst","4.3.2.1");
        message.put("sensor_uuid","sensor_UUID1");

        Map<String, Object> expectedMessage = new HashMap<>();
        expectedMessage.put("hash_score", 0);
        expectedMessage.put("dst", "4.3.2.1");
        expectedMessage.put("src", "1.2.3.4");
        expectedMessage.put("ip_direction", "destination");
        expectedMessage.put("type", "ips");
        expectedMessage.put("hash", "AAAA");
        expectedMessage.put("hash_list_type", "white");
        expectedMessage.put("url", "http://127.0.0.1/someURI_AAAA");
        expectedMessage.put("url_list_type", "white");
        expectedMessage.put("ip_score", 100);
        expectedMessage.put("ip_list_type", "black");
        expectedMessage.put("timestamp", 1111L);
        expectedMessage.put("url_score", 0);
        expectedMessage.put("application_id_name", "http");
        expectedMessage.put("sensor_uuid","sensor_UUID1");
        expectedMessage.put("file_name","someURI_AAAA");
        ipsProcessor.process(message, collector);


        assertEquals(expectedMessage, collector.getResult().get(0));

    }

    @Test
    public void ignoreEmptyMessagesTest(){
        MockMessageCollector collector = new MockMessageCollector();
        Map<String, Object> message = new HashMap<>();

        ipsProcessor.process(message, collector);

        assertTrue(collector.getResult().isEmpty());
    }

    @Test
    public void getNameTest(){
        assertEquals("IPS", ipsProcessor.getName());
    }

}
