package net.redborder.samza.processors;

import junit.framework.TestCase;
import net.redborder.samza.enrichments.EnrichManager;
import net.redborder.samza.store.StoreExtensionKey;
import net.redborder.samza.store.StoreManager;
import net.redborder.samza.stores.AerospikeStore;
import net.redborder.samza.util.MockKeyValueStore;
import net.redborder.samza.util.MockMessageCollector;
import net.redborder.samza.util.MockTaskContext;
import net.redborder.samza.util.constants.Constants;
import org.apache.samza.config.Config;
import org.apache.samza.task.TaskContext;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.runner.RunWith;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ScoresProcessorTest extends TestCase {

    static MockKeyValueStore storeScores;

    static ScoresProcessor scoresProcessor;

    static EnrichManager enrichManager;

    @Mock
    static Config config;

    @Mock
    static StoreManager storeManager;

    @Mock
    static AerospikeStore mockAerospikeStore;

    static TaskContext taskContext;

    static Map<String, Object> enrichMessage;

    @BeforeClass
    public static void initTest(){

        enrichMessage = new HashMap<>();

        storeScores = new MockKeyValueStore();
        taskContext = new MockTaskContext();
        enrichManager = new EnrichManager();

        config = mock(Config.class);
        storeManager = mock(StoreManager.class);
        mockAerospikeStore = mock(AerospikeStore.class);

        when(storeManager.getExtension("aerospike")).thenReturn(mockAerospikeStore);

        doCallRealMethod().when(mockAerospikeStore).updateHashTimes(anyObject(), anyString(), (Constants.EventType) anyObject());

        when(mockAerospikeStore.exist(any(StoreExtensionKey.class))).thenAnswer(new Answer<Object>() {
            @Override
            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
                StoreExtensionKey hashTimesKey = (StoreExtensionKey) invocationOnMock.getArguments()[0];

                String key = hashTimesKey.key;

                boolean exist = false;

                if(key.equals("AAAA")){
                    exist = true;
                }else if(key.equals("BBBB")){
                    exist = false;
                }

                return exist;
            }
        });

        doAnswer(new Answer() {
            @Override
            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
                enrichMessage.clear();
                enrichMessage.putAll((Map<String, Object>) invocationOnMock.getArguments()[1]);

                return null;
            }

        }).when(mockAerospikeStore).put(any(StoreExtensionKey.class), anyMap());

        scoresProcessor = new ScoresProcessor(storeManager, enrichManager, config, taskContext);
    }

    @Before
    public void cleanStore(){
        storeScores.flush();
    }

    @Test
    public void processMessageIfHashNotExistCorrectly(){
        MockMessageCollector collector = new MockMessageCollector();

        Map<String, Object> message = new HashMap<>();
        message.put("hash", "BBBB");
        message.put("timestamp", new Date(2222).getTime());

        Map<String, Object> expectedMessage = new HashMap<>();
        expectedMessage.put("hash", "BBBB");
        expectedMessage.put("time_end", 2222L);
        expectedMessage.put("time_start", 2222L);

        scoresProcessor.process(message, collector);

        assertEquals(expectedMessage, enrichMessage);

    }

    @Test
    public void processMessageIfHashExistCorrectly(){
        MockMessageCollector collector = new MockMessageCollector();

        Map<String, Object> message = new HashMap<>();
        message.put("hash", "AAAA");
        message.put("timestamp", new Date(1111).getTime());

        Map<String, Object> expectedMessage = new HashMap<>();
        expectedMessage.put("hash", "AAAA");
        expectedMessage.put("time_end", 1111L);

        scoresProcessor.process(message, collector);

        assertEquals(expectedMessage, enrichMessage);

    }

    @Test
    public void ignoreEmptyMessage(){
        MockMessageCollector collector = new MockMessageCollector();
        Map<String, Object> message = new HashMap<>();

        scoresProcessor.process(message, collector);

        assertTrue(collector.getResult().isEmpty());
    }

    @Test
    public void getNameTest(){
        assertEquals("ANALYSIS", scoresProcessor.getName());
    }

}
